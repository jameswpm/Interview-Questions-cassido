'''
Given the current position of a knight as [row, col] in an 8x8 chess board represented 
as a 2D array, write a function to return all valid moves the knight can make. 

Extra credit: Do this for every chess piece!

Example:

knightMoves([4, 4])
> [[2, 3], [2, 5], [3, 2], [3, 6], [5, 2], [5, 6], [6, 3], [6, 5]]

knightMoves([0, 0])
> [[1, 2], [2, 1]]

knightMoves([1, 2])
> [[0, 0], [0, 4], [2, 0], [2, 4], [3, 1], [3, 3]]
'''

def knightMoves(pos):
    next_potential_moves = []
    # start movement going up
    #going right
    v_up_0 = pos[0] + 2
    v_up_r_1 = pos[1] + 1
    if check_valid_position(v_up_0, v_up_r_1):
        next_potential_moves.append([v_up_0,v_up_r_1])
    # going left
    v_up_l_1 = pos[1] - 1
    if check_valid_position(v_up_0, v_up_l_1):
        next_potential_moves.append([v_up_0,v_up_l_1])
    # start the movement going down
    v_down_0 = pos[0] - 2
    # going right
    v_down_r_1 = pos[1] + 1
    if check_valid_position(v_down_0, v_down_r_1):
        next_potential_moves.append([v_down_0,v_down_r_1])
    # going left
    v_down_l_1 = pos[1] - 1
    if check_valid_position(v_down_0, v_down_l_1):
        # assume it's a valid position
        next_potential_moves.append([v_down_0,v_down_l_1])

    # start movement going right
    h_right_1 = pos[1] + 2
    h_right_up_0 = pos[0] + 1
    if check_valid_position(h_right_up_0, h_right_1):
        next_potential_moves.append([h_right_up_0, h_right_1])

    h_right_down_0 = pos[0] - 1
    if check_valid_position(h_right_down_0, h_right_1):
        next_potential_moves.append([h_right_down_0, h_right_1])
    #start the movement going left
    h_left_1 = pos[1] -2
    h_left_up_0 = pos[0] + 1
    if check_valid_position(h_left_up_0, h_left_1):
        next_potential_moves.append([h_left_up_0, h_left_1])
    h_left_down_0 = pos[0] - 1
    if check_valid_position(h_left_down_0, h_left_1):
        next_potential_moves.append([h_left_down_0, h_left_1])
    
    next_potential_moves.sort()
    return next_potential_moves

def check_valid_position(pos1, pos2):
    if pos1 >= 0 and pos1 <= 7 and pos2 >= 0 and pos2 <= 7:
        return [pos1,pos2]
    return None


if __name__ == "__main__":
    
    assert knightMoves([4, 4]
    ) == [[2, 3], [2, 5], [3, 2], [3, 6], [5, 2], [5, 6], [6, 3], [6, 5]]

    assert knightMoves([0, 0]
    ) == [[1, 2], [2, 1]]

    assert knightMoves([1, 2]
    ) == [[0, 0], [0, 4], [2, 0], [2, 4], [3, 1], [3, 3]]

    ## TESTS GENERATED BY CHATGPT
    # Corners
    assert knightMoves([0, 7]) == [[1, 5], [2, 6]]
    assert knightMoves([7, 0]) == [[5, 1], [6, 2]]
    assert knightMoves([7, 7]) == [[5, 6], [6, 5]]

    # Edge / near-corner positions (fixed: include all valid moves)
    assert knightMoves([0, 1]) == [[1, 3], [2, 0], [2, 2]]      # top edge
    assert knightMoves([1, 0]) == [[0, 2], [2, 2], [3, 1]]      # left edge
    assert knightMoves([6, 7]) == [[4, 6], [5, 5], [7, 5]]      # bottom edge (includes [7,5])
    assert knightMoves([7, 6]) == [[5, 5], [5, 7], [6, 4]]      # right edge (includes [5,7])

    # Center and middle-board positions
    assert knightMoves([3, 3]) == [
        [1, 2], [1, 4], [2, 1], [2, 5], [4, 1], [4, 5], [5, 2], [5, 4]
    ]
    assert knightMoves([2, 2]) == [
        [0, 1], [0, 3], [1, 0], [1, 4], [3, 0], [3, 4], [4, 1], [4, 3]
    ]

    # Additional edge checks
    assert knightMoves([4, 0]) == [[2, 1], [3, 2], [5, 2], [6, 1]]
    assert knightMoves([0, 4]) == [[1, 2], [1, 6], [2, 3], [2, 5]]
    assert knightMoves([7, 3]) == [[5, 2], [5, 4], [6, 1], [6, 5]]

    print("âœ… All tests passed!")







